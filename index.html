<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" href="favicon.png" type="image/x-icon">
    <title>Продвинутый стакан для скальпинга. <a href="manual.html" target="_blank">Инструкция</a></title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        body {
            background-color: #0f1923;
            color: #e8e8e8;
            padding: 20px;
        }
        
        .container {
            max-width: 1600px;
            margin: 0 auto;
        }
        
        header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px 0;
            border-bottom: 1px solid #26313d;
            margin-bottom: 20px;
        }
        
        h1 {
            color: #61dafb;
            font-size: 24px;
        }
        
        .controls {
            display: flex;
            gap: 15px;
            margin-bottom: 20px;
            flex-wrap: wrap;
            align-items: center;
        }
        
        .coins-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
            gap: 10px;
            margin-bottom: 20px;
            max-height: 200px;
            overflow-y: auto;
            padding: 10px;
            background-color: #1a2431;
            border-radius: 6px;
        }
        
        .coin-item {
            padding: 8px 12px;
            border-radius: 4px;
            cursor: pointer;
            text-align: center;
            transition: all 0.3s;
            border: 1px solid #344658;
            background-color: #1e2a38;
            position: relative;
        }
        
        .coin-item:hover {
            background-color: #2d3e50;
            transform: translateY(-2px);
        }
        
        .coin-item.selected {
            background-color: #2962ff;
            border-color: #2962ff;
        }
        
        .coin-item.rising {
            background: linear-gradient(135deg, #2d4a2c 0%, #1e3e1e 100%);
            border-color: #4caf50;
        }
        
        .coin-item.falling {
            background: linear-gradient(135deg, #4a2c2c 0%, #3e1e1e 100%);
            border-color: #f44336;
        }
        
        .coin-name {
            font-weight: bold;
            font-size: 12px;
        }
        
        .coin-price {
            font-size: 11px;
            color: #8c98a8;
        }
        
        .coin-change {
            font-size: 11px;
            font-weight: bold;
        }
        
        .change-up {
            color: #4caf50;
        }
        
        .change-down {
            color: #f44336;
        }
        
        .exchange-buttons {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }
        
        .exchange-btn {
            background-color: #2d3e50;
            border: 1px solid #344658;
            padding: 8px 15px;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .exchange-btn.active {
            background-color: #2962ff;
            border-color: #2962ff;
        }
        
        .exchange-btn:hover:not(.active) {
            background-color: #3a506b;
        }
        
        .mexc-trade-btn {
            background-color: #4caf50;
            border: 1px solid #43a047;
            padding: 8px 15px;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.3s;
            text-decoration: none;
            display: inline-block;
            color: white;
            font-size: 14px;
        }
        
        .mexc-trade-btn:hover {
            background-color: #43a047;
            transform: translateY(-1px);
        }
        
        input, select, button {
            background-color: #1e2a38;
            color: #e8e8e8;
            border: 1px solid #344658;
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 14px;
            outline: none;
        }
        
        input:focus, select:focus {
            border-color: #61dafb;
        }
        
        button {
            background-color: #2962ff;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        
        button:hover {
            background-color: #1a56e8;
        }
        
        .status {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 14px;
        }
        
        .status-indicator {
            width: 10px;
            height: 10px;
            border-radius: 50%;
        }
        
        .status-connected {
            background-color: #4caf50;
        }
        
        .status-error {
            background-color: #f44336;
        }
        
        .status-connecting {
            background-color: #ff9800;
        }
        
        .status-disconnected {
            background-color: #9e9e9e;
        }
        
        .orderbook {
            display: flex;
            gap: 20px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }
        
        .orderbook-section {
            flex: 1;
            min-width: 300px;
            background-color: #1a2431;
            border-radius: 6px;
            overflow: hidden;
        }
        
        .orderbook-header {
            background-color: #26313d;
            padding: 10px 15px;
            font-weight: bold;
            display: flex;
            justify-content: space-between;
        }
        
        .orderbook-content {
            height: 400px;
            overflow-y: auto;
        }
        
        .order-row {
            display: flex;
            justify-content: space-between;
            padding: 6px 15px;
            font-family: monospace;
            position: relative;
            overflow: hidden;
        }
        
        .order-row.bid:hover, .order-row.ask:hover {
            background-color: #26313d;
        }
        
        .bid .size-bar {
            position: absolute;
            top: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(76, 175, 80, 0.2);
            z-index: 0;
        }
        
        .ask .size-bar {
            position: absolute;
            top: 0;
            left: 0;
            bottom: 0;
            background-color: rgba(244, 67, 54, 0.2);
            z-index: 0;
        }
        
        .price {
            z-index: 1;
        }
        
        .size {
            z-index: 1;
        }
        
        .bid .price {
            color: #4caf50;
        }
        
        .ask .price {
            color: #f44336;
        }
        
        .support-level {
            background-color: rgba(76, 175, 80, 0.1);
            border-left: 3px solid #4caf50;
        }
        
        .resistance-level {
            background-color: rgba(244, 67, 54, 0.1);
            border-left: 3px solid #f44336;
        }
        
        .level-label {
            position: absolute;
            left: 5px;
            font-size: 9px;
            color: #8c98a8;
        }
        
        .spread {
            text-align: center;
            padding: 10px;
            background-color: #26313d;
            margin-bottom: 20px;
            border-radius: 4px;
            font-weight: bold;
        }
        
        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }
        
        .stat-card {
            background-color: #1a2431;
            padding: 15px;
            border-radius: 6px;
            position: relative;
        }
        
        .stat-title {
            font-size: 12px;
            color: #8c98a8;
            margin-bottom: 5px;
        }
        
        .stat-value {
            font-size: 18px;
            font-weight: bold;
        }
        
        .alert-indicator {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background-color: #4caf50;
            opacity: 0;
            transition: opacity 0.3s;
        }
        
        .alert-indicator.active {
            opacity: 1;
            animation: pulse 1s infinite;
        }
        
        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }
        
        .depth-chart {
            height: 200px;
            background-color: #1a2431;
            border-radius: 6px;
            margin-bottom: 20px;
            position: relative;
            overflow: hidden;
        }
        
        .depth-area {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            opacity: 0.3;
        }
        
        .bid-depth {
            background: linear-gradient(to right, rgba(76, 175, 80, 0.5), transparent);
        }
        
        .ask-depth {
            background: linear-gradient(to left, rgba(244, 67, 54, 0.5), transparent);
        }
        
        .last-price {
            position: absolute;
            top: 0;
            left: 50%;
            transform: translateX(-50%);
            background-color: #2962ff;
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            font-weight: bold;
        }
        
        .error-message {
            background-color: #4a2c2c;
            color: #ff6b6b;
            padding: 15px;
            border-radius: 6px;
            margin: 15px 0;
            border-left: 4px solid #f44336;
        }
        
        .alert-message {
            background-color: #2c4a2c;
            color: #4caf50;
            padding: 15px;
            border-radius: 6px;
            margin: 15px 0;
            border-left: 4px solid #4caf50;
            display: none;
        }
        
        .alert-message.warning {
            background-color: #4a3c2c;
            color: #ff9800;
            border-left: 4px solid #ff9800;
        }
        
        .alert-message.danger {
            background-color: #4a2c2c;
            color: #f44336;
            border-left: 4px solid #f44336;
        }
        
        .alert-message.visible {
            display: block;
            animation: slideIn 0.5s ease;
        }
        
        @keyframes slideIn {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .retry-button {
            background-color: #f44336;
            margin-top: 10px;
        }
        
        .retry-button:hover {
            background-color: #e53935;
        }
        
        .connection-info {
            background-color: #1a2431;
            padding: 10px;
            border-radius: 4px;
            margin: 10px 0;
            font-size: 12px;
            color: #8c98a8;
        }
        
        .cluster-info {
            background-color: #1a2431;
            padding: 10px;
            border-radius: 4px;
            margin: 10px 0;
            font-size: 12px;
        }
        
        .cluster-bar {
            height: 10px;
            background: linear-gradient(90deg, #4caf50 0%, #ff9800 50%, #f44336 100%);
            border-radius: 5px;
            margin: 5px 0;
            position: relative;
        }
        
        .cluster-marker {
            position: absolute;
            top: -2px;
            width: 2px;
            height: 14px;
            background-color: white;
        }
        
        .advice-container {
            background-color: #1a2431;
            padding: 15px;
            border-radius: 6px;
            margin: 15px 0;
        }
        
        .advice-title {
            font-weight: bold;
            margin-bottom: 10px;
            color: #61dafb;
        }
        
        .advice-content {
            font-size: 14px;
            line-height: 1.5;
        }
        
        @media (max-width: 768px) {
            .orderbook {
                flex-direction: column;
            }
            
            .orderbook-section {
                width: 100%;
            }
            
            .exchange-buttons {
                flex-direction: column;
                width: 100%;
            }
            
            .exchange-btn {
                width: 100%;
                text-align: center;
            }
            
            .coins-grid {
                grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
            }
            
            .mexc-trade-btn {
                width: 100%;
                text-align: center;
                margin-top: 10px;
            }
        }
        
        .loading {
            text-align: center;
            padding: 20px;
            color: #8c98a8;
        }
        
        .ws-status {
            font-size: 12px;
            color: #8c98a8;
            margin-left: 10px;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Продвинутый стакан для скальпинга</h1>
            <div class="status">
                <div class="status-indicator status-disconnected" id="statusIndicator"></div>
                <span id="statusText">Выберите биржу и монету</span>
                <span class="ws-status" id="wsStatus"></span>
            </div>
        </header>
        
        <div class="controls">
            <div class="coins-grid" id="coinsGrid">
                <!-- Монеты будут добавлены через JavaScript -->
            </div>
            
            <div class="exchange-buttons">
                <button class="exchange-btn" data-exchange="binance">Binance</button>
                <button class="exchange-btn" data-exchange="bybit">Bybit</button>
                <button class="exchange-btn" data-exchange="mexc">MEXC</button>
                <button class="exchange-btn" data-exchange="kucoin">KuCoin</button>
                <button class="exchange-btn" data-exchange="gateio">Gate.io</button>
                <button class="exchange-btn" data-exchange="okx">OKX</button>
                <button class="exchange-btn" data-exchange="htx">HTX</button>
            </div>
            
            <input type="text" id="symbolInput" placeholder="Введите пару (BTCUSDT)" value="">
            <select id="timeframeSelect">
                <option value="1000">1 секунда</option>
                <option value="2000">2 секунды</option>
                <option value="5000">5 секунд</option>
                <option value="10000" selected>10 секунд</option>
            </select>
            <button id="connectBtn">Подключиться</button>
            <a href="#" id="mexcTradeBtn" class="mexc-trade-btn" target="_blank" style="display: none;">
                📊 Торговать на MEXC
            </a>
        </div>
        
        <div class="connection-info">
            💡 Для разных бирж используйте соответствующий формат: Binance: BTCUSDT, MEXC: BTCUSDT, KuCoin: BTC-USDT, Gate.io: BTC_USDT
        </div>
        
        <div id="errorContainer"></div>
        
        <div class="alert-message" id="trendAlert">
            <strong>📈 Восходящий тренд:</strong> Объем покупок превышает продажи на <span id="trendStrength">0</span>%
            <div class="advice-content" id="trendAdvice"></div>
        </div>
        
        <div class="alert-message warning" id="warningAlert" style="display: none;">
            <strong>⚠️ Предупреждение:</strong> <span id="warningText"></span>
            <div class="advice-content" id="warningAdvice"></div>
        </div>
        
        <div class="alert-message danger" id="dangerAlert" style="display: none;">
            <strong>🔴 Опасность:</strong> <span id="dangerText"></span>
            <div class="advice-content" id="dangerAdvice"></div>
        </div>
        
        <div class="spread" id="spreadElement">
            Спред: Выберите биржу и монету
        </div>
        
        <div class="orderbook">
            <div class="orderbook-section">
                <div class="orderbook-header">
                    <span>Покупка (Bid)</span>
                    <span>Объем</span>
                </div>
                <div class="orderbook-content" id="bidsContainer">
                    <div class="loading">Выберите биржу и монету</div>
                </div>
            </div>
            
            <div class="orderbook-section">
                <div class="orderbook-header">
                    <span>Продажа (Ask)</span>
                    <span>Объем</span>
                </div>
                <div class="orderbook-content" id="asksContainer">
                    <div class="loading">Выберите биржу и монету</div>
                </div>
            </div>
        </div>
        
        <div class="depth-chart" id="depthChart">
            <div class="depth-area bid-depth" id="bidDepth"></div>
            <div class="depth-area ask-depth" id="askDepth"></div>
            <div class="last-price" id="lastPrice">0</div>
        </div>
        
        <div class="cluster-info">
            <div class="stat-title">Кластерный анализ ликвидности</div>
            <div class="cluster-bar" id="clusterBar">
                <div class="cluster-marker" id="clusterMarker" style="left: 50%;"></div>
            </div>
            <div id="clusterText">Нейтральная ликвидность</div>
        </div>
        
        <div class="stats">
            <div class="stat-card">
                <div class="stat-title">Общий объем покупок</div>
                <div class="stat-value" id="totalBidVolume">0</div>
                <div class="alert-indicator" id="bidAlert"></div>
            </div>
            <div class="stat-card">
                <div class="stat-title">Общий объем продаж</div>
                <div class="stat-value" id="totalAskVolume">0</div>
            </div>
            <div class="stat-card">
                <div class="stat-title">Дисбаланс стакана</div>
                <div class="stat-value" id="orderbookImbalance">0%</div>
                <div class="alert-indicator" id="imbalanceAlert"></div>
            </div>
            <div class="stat-card">
                <div class="stat-title">Макс. плотность покупки</div>
                <div class="stat-value" id="maxBidDensity">0</div>
            </div>
            <div class="stat-card">
                <div class="stat-title">Макс. плотность продажи</div>
                <div class="stat-value" id="maxAskDensity">0</div>
            </div>
            <div class="stat-card">
                <div class="stat-title">Соотношение объемов</div>
                <div class="stat-value" id="volumeRatio">1:1</div>
                <div class="alert-indicator" id="ratioAlert"></div>
            </div>
            <div class="stat-card">
                <div class="stat-title">Изменение за 5 мин</div>
                <div class="stat-value" id="priceChange">0%</div>
            </div>
        </div>
        
        <div class="advice-container">
            <div class="advice-title">📋 Торговые рекомендации</div>
            <div class="advice-content" id="tradingAdvice">
                Выберите биржу и монету для получения торговых рекомендаций
            </div>
        </div>
    </div>

    <script>
        // Основные переменные
        let currentSymbol = '';
        let currentTimeframe = 10000;
        let currentExchange = null;
        let orderbook = { bids: {}, asks: {} };
        let isConnected = false;
        let updateInterval = null;
        let retryCount = 0;
        const MAX_RETRIES = 3;
        let alertTimeout = null;
        let coinPrices = {};
        let priceHistory = [];
        let ws = null;
        let useWebSocket = true;
        let supportLevels = [];
        let resistanceLevels = [];
        let lastProcessedData = null;
        
        // Элементы DOM
        const statusIndicator = document.getElementById('statusIndicator');
        const statusText = document.getElementById('statusText');
        const wsStatus = document.getElementById('wsStatus');
        const coinsGrid = document.getElementById('coinsGrid');
        const symbolInput = document.getElementById('symbolInput');
        const timeframeSelect = document.getElementById('timeframeSelect');
        const connectBtn = document.getElementById('connectBtn');
        const mexcTradeBtn = document.getElementById('mexcTradeBtn');
        const errorContainer = document.getElementById('errorContainer');
        const trendAlert = document.getElementById('trendAlert');
        const warningAlert = document.getElementById('warningAlert');
        const dangerAlert = document.getElementById('dangerAlert');
        const trendStrength = document.getElementById('trendStrength');
        const warningText = document.getElementById('warningText');
        const dangerText = document.getElementById('dangerText');
        const trendAdvice = document.getElementById('trendAdvice');
        const warningAdvice = document.getElementById('warningAdvice');
        const dangerAdvice = document.getElementById('dangerAdvice');
        const spreadElement = document.getElementById('spreadElement');
        const bidsContainer = document.getElementById('bidsContainer');
        const asksContainer = document.getElementById('asksContainer');
        const bidDepth = document.getElementById('bidDepth');
        const askDepth = document.getElementById('askDepth');
        const lastPrice = document.getElementById('lastPrice');
        const totalBidVolume = document.getElementById('totalBidVolume');
        const totalAskVolume = document.getElementById('totalAskVolume');
        const orderbookImbalance = document.getElementById('orderbookImbalance');
        const maxBidDensity = document.getElementById('maxBidDensity');
        const maxAskDensity = document.getElementById('maxAskDensity');
        const volumeRatio = document.getElementById('volumeRatio');
        const priceChange = document.getElementById('priceChange');
        const bidAlert = document.getElementById('bidAlert');
        const imbalanceAlert = document.getElementById('imbalanceAlert');
        const ratioAlert = document.getElementById('ratioAlert');
        const tradingAdvice = document.getElementById('tradingAdvice');
        const clusterBar = document.getElementById('clusterBar');
        const clusterMarker = document.getElementById('clusterMarker');
        const clusterText = document.getElementById('clusterText');
        
        // Обновленный список популярных монет с проверкой доступности на биржах
        const popularCoins = [
            { symbol: 'BTCUSDT', name: 'BTC', price: 61452, change: 2.5, available: ['binance', 'bybit', 'mexc', 'kucoin', 'gateio', 'okx', 'htx'] },
            { symbol: 'ETHUSDT', name: 'ETH', price: 3410, change: 1.8, available: ['binance', 'bybit', 'mexc', 'kucoin', 'gateio', 'okx', 'htx'] },
            { symbol: 'BNBUSDT', name: 'BNB', price: 586, change: 3.2, available: ['binance', 'bybit', 'mexc', 'kucoin', 'gateio', 'okx', 'htx'] },
            { symbol: 'SOLUSDT', name: 'SOL', price: 142, change: 5.7, available: ['binance', 'bybit', 'mexc', 'kucoin', 'gateio', 'okx', 'htx'] },
            { symbol: 'XRPUSDT', name: 'XRP', price: 0.487, change: 2.1, available: ['binance', 'bybit', 'mexc', 'kucoin', 'gateio', 'okx', 'htx'] },
            { symbol: 'DOGEUSDT', name: 'DOGE', price: 0.123, change: 8.5, available: ['binance', 'bybit', 'mexc', 'kucoin', 'gateio', 'okx', 'htx'] },
            { symbol: 'TONUSDT', name: 'TON', price: 7.35, change: 4.3, available: ['binance', 'bybit', 'mexc', 'kucoin', 'gateio', 'okx', 'htx'] },
            { symbol: 'ADAUSDT', name: 'ADA', price: 0.432, change: 1.9, available: ['binance', 'bybit', 'mexc', 'kucoin', 'gateio', 'okx', 'htx'] },
            { symbol: 'AVAXUSDT', name: 'AVAX', price: 27.8, change: 6.2, available: ['binance', 'bybit', 'mexc', 'kucoin', 'gateio', 'okx', 'htx'] },
            { symbol: 'SHIBUSDT', name: 'SHIB', price: 0.0000215, change: 12.7, available: ['binance', 'bybit', 'mexc', 'kucoin', 'gateio', 'okx', 'htx'] },
            { symbol: 'DOTUSDT', name: 'DOT', price: 6.23, change: 3.4, available: ['binance', 'bybit', 'mexc', 'kucoin', 'gateio', 'okx', 'htx'] },
            { symbol: 'LINKUSDT', name: 'LINK', price: 13.47, change: 2.8, available: ['binance', 'bybit', 'mexc', 'kucoin', 'gateio', 'okx', 'htx'] },
            { symbol: 'MATICUSDT', name: 'MATIC', price: 0.567, change: 1.5, available: ['binance', 'bybit', 'mexc', 'kucoin', 'gateio', 'okx', 'htx'] },
            { symbol: 'TRXUSDT', name: 'TRX', price: 0.117, change: 0.9, available: ['binance', 'bybit', 'mexc', 'kucoin', 'gateio', 'okx', 'htx'] },
            { symbol: 'BCHUSDT', name: 'BCH', price: 385, change: 2.3, available: ['binance', 'bybit', 'mexc', 'kucoin', 'gateio', 'okx', 'htx'] },
            { symbol: 'LTCUSDT', name: 'LTC', price: 74.3, change: 1.7, available: ['binance', 'bybit', 'mexc', 'kucoin', 'gateio', 'okx', 'htx'] },
            { symbol: 'UNIUSDT', name: 'UNI', price: 9.12, change: 4.1, available: ['binance', 'bybit', 'mexc', 'kucoin', 'gateio', 'okx', 'htx'] },
            { symbol: 'ATOMUSDT', name: 'ATOM', price: 7.85, change: 2.6, available: ['binance', 'bybit', 'mexc', 'kucoin', 'gateio', 'okx', 'htx'] },
            { symbol: 'XLMUSDT', name: 'XLM', price: 0.105, change: 1.2, available: ['binance', 'bybit', 'mexc', 'kucoin', 'gateio', 'okx', 'htx'] },
            { symbol: 'XMRUSDT', name: 'XMR', price: 168, change: 0.8, available: ['binance', 'bybit', 'mexc', 'kucoin', 'gateio', 'okx'] },
            { symbol: 'ETCUSDT', name: 'ETC', price: 26.4, change: 1.4, available: ['binance', 'bybit', 'mexc', 'kucoin', 'gateio', 'okx', 'htx'] },
            { symbol: 'FILUSDT', name: 'FIL', price: 5.67, change: 3.9, available: ['binance', 'bybit', 'mexc', 'kucoin', 'gateio', 'okx', 'htx'] },
            { symbol: 'APTUSDT', name: 'APT', price: 8.32, change: 7.3, available: ['binance', 'bybit', 'mexc', 'kucoin', 'gateio', 'okx'] },
            { symbol: 'ARBUSDT', name: 'ARB', price: 0.945, change: 5.6, available: ['binance', 'bybit', 'mexc', 'kucoin', 'gateio', 'okx'] },
            { symbol: 'NEARUSDT', name: 'NEAR', price: 5.21, change: 6.8, available: ['binance', 'bybit', 'mexc', 'kucoin', 'gateio', 'okx', 'htx'] },
            { symbol: 'VETUSDT', name: 'VET', price: 0.0312, change: 2.5, available: ['binance', 'bybit', 'mexc', 'kucoin', 'gateio', 'okx', 'htx'] },
            { symbol: 'RUNEUSDT', name: 'RUNE', price: 4.35, change: 8.2, available: ['binance', 'bybit', 'mexc', 'kucoin', 'gateio', 'okx'] },
            { symbol: 'AAVEUSDT', name: 'AAVE', price: 102.3, change: 4.7, available: ['binance', 'bybit', 'mexc', 'kucoin', 'gateio', 'okx'] },
            { symbol: 'ALGOUSDT', name: 'ALGO', price: 0.162, change: 3.1, available: ['binance', 'bybit', 'mexc', 'kucoin', 'gateio', 'okx', 'htx'] },
            { symbol: 'QNTUSDT', name: 'QNT', price: 86.5, change: 2.2, available: ['binance', 'bybit', 'mexc', 'kucoin', 'gateio', 'okx'] }
        ];
        
        // Сортируем монеты по проценту изменения
        popularCoins.sort((a, b) => b.change - a.change);
        
        // API endpoints для разных бирж с улучшенной обработкой
        const exchangeAPIs = {
            binance: {
                rest: {
                    depth: (symbol) => `https://api.binance.com/api/v3/depth?symbol=${symbol}&limit=1000`,
                    exchangeInfo: `https://api.binance.com/api/v3/exchangeInfo`
                },
                ws: {
                    depth: (symbol) => `wss://stream.binance.com:9443/ws/${symbol.toLowerCase()}@depth20@1000ms`
                },
                name: 'Binance',
                format: 'BTCUSDT',
                formatExample: 'BTCUSDT'
            },
            bybit: {
                rest: {
                    depth: (symbol) => `https://api.bybit.com/v5/market/orderbook?category=spot&symbol=${symbol}&limit=1000`
                },
                ws: {
                    depth: (symbol) => `wss://stream.bybit.com/v5/public/spot`
                },
                name: 'Bybit',
                format: 'BTCUSDT',
                formatExample: 'BTCUSDT'
            },
            mexc: {
                rest: {
                    depth: (symbol) => `https://api.mexc.com/api/v3/depth?symbol=${symbol}&limit=1000`
                },
                name: 'MEXC',
                format: 'BTCUSDT',
                formatExample: 'BTCUSDT',
                tradeUrl: (symbol) => `https://www.mexc.com/ru-RU/exchange/${symbol.replace('USDT', '_USDT')}`
            },
            kucoin: {
                rest: {
                    depth: (symbol) => `https://api.kucoin.com/api/v1/market/orderbook/level2_100?symbol=${symbol.replace('USDT', '-USDT')}`
                },
                name: 'KuCoin',
                format: 'BTC-USDT',
                formatExample: 'BTC-USDT'
            },
            gateio: {
                rest: {
                    depth: (symbol) => `https://api.gateio.ws/api/v4/spot/order_book?currency_pair=${symbol.replace('USDT', '_USDT')}&limit=1000`
                },
                name: 'Gate.io',
                format: 'BTC_USDT',
                formatExample: 'BTC_USDT'
            },
            okx: {
                rest: {
                    depth: (symbol) => `https://www.okx.com/api/v5/market/books?instId=${symbol}&sz=400`
                },
                name: 'OKX',
                format: 'BTC-USDT',
                formatExample: 'BTC-USDT'
            },
            htx: {
                rest: {
                    depth: (symbol) => `https://api.huobi.pro/market/depth?symbol=${symbol.toLowerCase()}&type=step0&depth=100`
                },
                name: 'HTX',
                format: 'btcusdt',
                formatExample: 'btcusdt'
            }
        };
        
        // Инициализация
        document.addEventListener('DOMContentLoaded', init);
        
        function init() {
            // Заполняем сетку монет
            renderCoinsGrid();
            
            // Настройка обработчиков событий
            connectBtn.addEventListener('click', handleConnect);
            
            // Обработчики для кнопок бирж
            document.querySelectorAll('.exchange-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    document.querySelectorAll('.exchange-btn').forEach(b => b.classList.remove('active'));
                    e.target.classList.add('active');
                    currentExchange = e.target.dataset.exchange;
                    statusText.textContent = `Выбрана биржа: ${exchangeAPIs[currentExchange].name}`;
                    
                    // Обновляем доступные монеты
                    updateAvailableCoins();
                    
                    // Показываем/скрываем кнопку торговли на MEXC
                    if (currentExchange === 'mexc' && currentSymbol) {
                        mexcTradeBtn.style.display = 'inline-block';
                        updateMexcTradeLink();
                    } else {
                        mexcTradeBtn.style.display = 'none';
                    }
                });
            });
            
            // Выбираем Binance по умолчанию
            document.querySelector('[data-exchange="binance"]').click();
            
            // Устанавливаем обработчик изменения таймфрейма
            timeframeSelect.addEventListener('change', () => {
                currentTimeframe = parseInt(timeframeSelect.value);
                if (isConnected) {
                    clearInterval(updateInterval);
                    updateInterval = setInterval(fetchOrderbookData, currentTimeframe);
                }
            });
        }
        
        // Обновление списка доступных монет для выбранной биржи
        function updateAvailableCoins() {
            const coinItems = document.querySelectorAll('.coin-item');
            coinItems.forEach(item => {
                const symbol = item.dataset.symbol;
                const coin = popularCoins.find(c => c.symbol === symbol);
                if (coin && coin.available.includes(currentExchange)) {
                    item.style.opacity = '1';
                    item.style.cursor = 'pointer';
                } else {
                    item.style.opacity = '0.5';
                    item.style.cursor = 'not-allowed';
                }
            });
        }
        
        // Отрисовка сетки монет
        function renderCoinsGrid() {
            coinsGrid.innerHTML = '';
            
            popularCoins.forEach(coin => {
                const coinElement = document.createElement('div');
                coinElement.className = 'coin-item';
                coinElement.classList.add(coin.change >= 0 ? 'rising' : 'falling');
                coinElement.dataset.symbol = coin.symbol;
                
                coinElement.innerHTML = `
                    <div class="coin-name">${coin.name}</div>
                    <div class="coin-price">$${coin.price.toFixed(coin.price < 0.01 ? 6 : 2)}</div>
                    <div class="coin-change ${coin.change >= 0 ? 'change-up' : 'change-down'}">
                        ${coin.change >= 0 ? '+' : ''}${coin.change.toFixed(1)}%
                    </div>
                `;
                
                coinElement.addEventListener('click', () => {
                    if (!coin.available.includes(currentExchange)) {
                        showError(`Монета ${coin.name} недоступна на ${exchangeAPIs[currentExchange].name}`);
                        return;
                    }
                    
                    document.querySelectorAll('.coin-item').forEach(item => {
                        item.classList.remove('selected');
                    });
                    coinElement.classList.add('selected');
                    
                    currentSymbol = coin.symbol;
                    symbolInput.value = coin.symbol;
                    statusText.textContent = `Выбрана монета: ${coin.name}`;
                    
                    // Обновляем ссылку для торговли на MEXC
                    if (currentExchange === 'mexc') {
                        mexcTradeBtn.style.display = 'inline-block';
                        updateMexcTradeLink();
                    }
                    
                    // Автоматическое подключение при выборе монеты
                    if (currentExchange) {
                        handleConnect();
                    }
                });
                
                coinsGrid.appendChild(coinElement);
            });
        }
        
        // Обновление ссылки для торговли на MEXC
        function updateMexcTradeLink() {
            if (currentSymbol && exchangeAPIs.mexc.tradeUrl) {
                const tradingSymbol = currentSymbol.replace('USDT', '_USDT');
                mexcTradeBtn.href = `https://www.mexc.com/ru-RU/exchange/${tradingSymbol}`;
                mexcTradeBtn.title = `Торговать ${currentSymbol} на MEXC`;
            }
        }
        
        // Обработчик подключения
        function handleConnect() {
            if (!currentExchange) {
                showError('Сначала выберите биржу');
                return;
            }
            
            let newSymbol = symbolInput.value.trim().toUpperCase();
            
            if (!newSymbol) {
                showError('Введите торговую пару');
                return;
            }
            
            // Нормализация символа для разных бирж
            newSymbol = normalizeSymbol(newSymbol, currentExchange);
            
            if (newSymbol !== currentSymbol) {
                currentSymbol = newSymbol;
                symbolInput.value = newSymbol;
            }
            
            currentTimeframe = parseInt(timeframeSelect.value);
            
            // Останавливаем предыдущий интервал и WebSocket
            if (updateInterval) {
                clearInterval(updateInterval);
            }
            
            if (ws) {
                ws.close();
                ws = null;
            }
            
            // Сбрасываем стакан
            resetOrderbook();
            clearError();
            hideAlerts();
            
            // Показываем статус подключения
            setStatus('connecting', `Подключение к ${exchangeAPIs[currentExchange].name}...`);
            
            // Пытаемся использовать WebSocket, если доступно
            if (exchangeAPIs[currentExchange].ws && exchangeAPIs[currentExchange].ws.depth) {
                useWebSocket = true;
                setupWebSocket();
            } else {
                useWebSocket = false;
                wsStatus.textContent = "REST API";
                // Запускаем обновление данных через REST API
                fetchOrderbookData();
                updateInterval = setInterval(fetchOrderbookData, currentTimeframe);
            }
        }
        
        // Настройка WebSocket соединения
        function setupWebSocket() {
            try {
                let wsUrl;
                
                switch(currentExchange) {
                    case 'binance':
                        wsUrl = exchangeAPIs.binance.ws.depth(currentSymbol);
                        break;
                    case 'bybit':
                        wsUrl = exchangeAPIs.bybit.ws.depth;
                        break;
                    default:
                        useWebSocket = false;
                        wsStatus.textContent = "REST API";
                        fetchOrderbookData();
                        updateInterval = setInterval(fetchOrderbookData, currentTimeframe);
                        return;
                }
                
                ws = new WebSocket(wsUrl);
                wsStatus.textContent = "WebSocket";
                
                ws.onopen = () => {
                    setStatus('connected', `WebSocket подключен к ${exchangeAPIs[currentExchange].name}: ${currentSymbol}`);
                    
                    // Для Bybit нужно отправить подписку
                    if (currentExchange === 'bybit') {
                        const subscribeMessage = {
                            op: "subscribe",
                            args: [`orderbook.100.${currentSymbol}`]
                        };
                        ws.send(JSON.stringify(subscribeMessage));
                    }
                };
                
                ws.onmessage = (event) => {
                    const data = JSON.parse(event.data);
                    
                    try {
                        let processedData;
                        
                        switch(currentExchange) {
                            case 'binance':
                                processedData = {
                                    bids: data.bids,
                                    asks: data.asks
                                };
                                break;
                            case 'bybit':
                                if (data.topic === `orderbook.100.${currentSymbol}`) {
                                    processedData = {
                                        bids: data.data.b,
                                        asks: data.data.a
                                    };
                                }
                                break;
                        }
                        
                        if (processedData) {
                            processOrderbookData(processedData);
                            isConnected = true;
                            retryCount = 0;
                        }
                    } catch (error) {
                        console.error('Error processing WS data:', error);
                    }
                };
                
                ws.onerror = (error) => {
                    console.error('WebSocket error:', error);
                    wsStatus.textContent = "Ошибка WebSocket";
                    useWebSocket = false;
                    
                    // Переключаемся на REST API
                    fetchOrderbookData();
                    updateInterval = setInterval(fetchOrderbookData, currentTimeframe);
                };
                
                ws.onclose = () => {
                    if (isConnected) {
                        wsStatus.textContent = "WebSocket закрыт";
                        // Переключаемся на REST API
                        fetchOrderbookData();
                        updateInterval = setInterval(fetchOrderbookData, currentTimeframe);
                    }
                };
                
            } catch (error) {
                console.error('WebSocket setup error:', error);
                useWebSocket = false;
                wsStatus.textContent = "REST API";
                fetchOrderbookData();
                updateInterval = setInterval(fetchOrderbookData, currentTimeframe);
            }
        }
        
        // Нормализация символа для разных бирж
        function normalizeSymbol(symbol, exchange) {
            // Удаляем все разделители
            let cleanSymbol = symbol.replace(/[\/_\-]/g, '');
            
            // Добавляем USDT если нужно
            if (!cleanSymbol.endsWith('USDT')) {
                cleanSymbol += 'USDT';
            }
            
            // Для конкретных бирж применяем нужный формат
            switch(exchange) {
                case 'kucoin':
                    return cleanSymbol.replace('USDT', '-USDT');
                case 'gateio':
                    return cleanSymbol.replace('USDT', '_USDT');
                case 'htx':
                    return cleanSymbol.toLowerCase();
                default:
                    return cleanSymbol;
            }
        }
        
        // Получение данных стакана с улучшенной обработкой ошибок
        async function fetchOrderbookData() {
            try {
                const apiUrl = exchangeAPIs[currentExchange].rest.depth(currentSymbol);
                const timestamp = new Date().getTime();
                const urlWithTimestamp = `${apiUrl}${apiUrl.includes('?') ? '&' : '?'}_=${timestamp}`;
                
                // Увеличиваем timeout для запроса
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 10000);
                
                const response = await fetch(urlWithTimestamp, {
                    signal: controller.signal,
                    headers: {
                        'Accept': 'application/json',
                    }
                });
                
                clearTimeout(timeoutId);
                
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                const data = await response.json();
                
                // Обработка данных в зависимости от биржи
                let processedData;
                switch(currentExchange) {
                    case 'binance':
                        processedData = data;
                        break;
                    case 'bybit':
                        if (data.retCode !== 0) throw new Error(data.retMsg || `Code: ${data.retCode}`);
                        processedData = {
                            bids: data.result.b,
                            asks: data.result.a
                        };
                        break;
                    case 'mexc':
                        if (data.code) throw new Error(data.msg || `Code: ${data.code}`);
                        processedData = data;
                        break;
                    case 'kucoin':
                        if (data.code !== '200000') throw new Error(data.msg || `Code: ${data.code}`);
                        processedData = {
                            bids: data.data.bids,
                            asks: data.data.asks
                        };
                        break;
                    case 'gateio':
                        processedData = {
                            bids: data.bids,
                            asks: data.asks
                        };
                        break;
                    case 'okx':
                        if (data.code !== '0') throw new Error(data.msg || `Code: ${data.code}`);
                        processedData = {
                            bids: data.data[0].bids,
                            asks: data.data[0].asks
                        };
                        break;
                    case 'htx':
                        if (data.status === 'error') throw new Error(data.err-msg || 'Error response');
                        processedData = {
                            bids: data.tick.bids,
                            asks: data.tick.asks
                        };
                        break;
                    default:
                        processedData = data;
                }
                
                processOrderbookData(processedData);
                isConnected = true;
                setStatus('connected', `Подключено к ${exchangeAPIs[currentExchange].name}: ${currentSymbol}`);
                retryCount = 0;
                
            } catch (error) {
                console.error('Error fetching orderbook data:', error);
                isConnected = false;
                
                if (error.name === 'AbortError') {
                    showError('Таймаут подключения. Проверьте интернет-соединение.', true);
                } else if (retryCount < MAX_RETRIES) {
                    retryCount++;
                    setStatus('error', `Ошибка (попытка ${retryCount}/${MAX_RETRIES})`);
                    setTimeout(() => fetchOrderbookData(), 2000);
                } else {
                    setStatus('error', 'Ошибка подключения');
                    showError(`Не удалось подключиться к ${exchangeAPIs[currentExchange].name}. Попробуйте другую биржу или проверьте название пары.`, true);
                }
            }
        }
        
        // Обработка данных стакана
        function processOrderbookData(data) {
            if (!data || !data.bids || !data.asks) {
                throw new Error('Некорректные данные от сервера');
            }
            
            // Сохраняем данные для анализа изменений
            lastProcessedData = JSON.parse(JSON.stringify(orderbook));
            
            orderbook = {
                bids: {},
                asks: {}
            };
            
            // Обработка покупок (bids)
            data.bids.forEach(bid => {
                const price = parseFloat(bid[0]);
                const quantity = parseFloat(bid[1]);
                if (!isNaN(price) && !isNaN(quantity)) {
                    orderbook.bids[price] = quantity;
                }
            });
            
            // Обработка продаж (asks)
            data.asks.forEach(ask => {
                const price = parseFloat(ask[0]);
                const quantity = parseFloat(ask[1]);
                if (!isNaN(price) && !isNaN(quantity)) {
                    orderbook.asks[price] = quantity;
                }
            });
            
            if (Object.keys(orderbook.bids).length === 0 || Object.keys(orderbook.asks).length === 0) {
                throw new Error('Нет данных для отображения. Возможно, неверное название пары.');
            }
            
            // Обновляем историю цен
            updatePriceHistory();
            
            // Определяем уровни поддержки и сопротивления
            identifySupportResistanceLevels();
            
            renderOrderbook();
            calculateStats();
            checkTrendAlerts();
            updateTradingAdvice();
            clearError();
        }
        
        // Обновление истории цен
        function updatePriceHistory() {
            const bidPrices = Object.keys(orderbook.bids).map(Number);
            const askPrices = Object.keys(orderbook.asks).map(Number);
            
            if (bidPrices.length === 0 || askPrices.length === 0) return;
            
            const bestBid = Math.max(...bidPrices);
            const bestAsk = Math.min(...askPrices);
            const midPrice = (bestBid + bestAsk) / 2;
            
            const now = Date.now();
            priceHistory.push({ price: midPrice, time: now });
            
            // Сохраняем только последние 100 значений
            if (priceHistory.length > 100) {
                priceHistory.shift();
            }
            
            // Рассчитываем изменение цены за 5 минут
            const fiveMinutesAgo = now - 5 * 60 * 1000;
            const pastPrice = priceHistory.find(p => p.time >= fiveMinutesAgo);
            
            if (pastPrice) {
                const change = ((midPrice - pastPrice.price) / pastPrice.price) * 100;
                priceChange.textContent = `${change >= 0 ? '+' : ''}${change.toFixed(2)}%`;
                priceChange.style.color = change >= 0 ? '#4caf50' : '#f44336';
            }
        }
        
        // Определение уровней поддержки и сопротивления
        function identifySupportResistanceLevels() {
            supportLevels = [];
            resistanceLevels = [];
            
            const bidPrices = Object.keys(orderbook.bids).map(Number).sort((a, b) => b - a);
            const askPrices = Object.keys(orderbook.asks).map(Number).sort((a, b) => a - b);
            
            if (bidPrices.length < 10 || askPrices.length < 10) return;
            
            // Ищем значительные уровни в стакане (кластеры)
            const significantLevels = [];
            const allLevels = [...bidPrices.slice(0, 20), ...askPrices.slice(0, 20)];
            
            // Группируем близкие цены
            const groupedLevels = {};
            allLevels.forEach(price => {
                const roundedPrice = parseFloat(price.toFixed(getPricePrecision()));
                if (!groupedLevels[roundedPrice]) {
                    groupedLevels[roundedPrice] = 0;
                }
                groupedLevels[roundedPrice] += orderbook.bids[price] || orderbook.asks[price] || 0;
            });
            
            // Находим уровни с наибольшим объемом
            const sortedLevels = Object.entries(groupedLevels)
                .sort((a, b) => b[1] - a[1])
                .slice(0, 5);
            
            const midPrice = (bidPrices[0] + askPrices[0]) / 2;
            
            sortedLevels.forEach(([price, volume]) => {
                const priceNum = parseFloat(price);
                if (priceNum < midPrice) {
                    supportLevels.push(priceNum);
                } else {
                    resistanceLevels.push(priceNum);
                }
            });
        }
        
        // Проверка сигналов восходящего тренда
        function checkTrendAlerts() {
            const bidValues = Object.values(orderbook.bids);
            const askValues = Object.values(orderbook.asks);
            
            if (bidValues.length === 0 || askValues.length === 0) return;
            
            const totalBid = bidValues.reduce((sum, vol) => sum + vol, 0);
            const totalAsk = askValues.reduce((sum, vol) => sum + vol, 0);
            const totalVolume = totalBid + totalAsk;
            
            if (totalVolume === 0) return;
            
            const bidRatio = (totalBid / totalVolume) * 100;
            const askRatio = (totalAsk / totalVolume) * 100;
            const imbalance = ((totalBid - totalAsk) / totalVolume) * 100;
            
            // Обновляем кластерный анализ
            updateClusterAnalysis(bidRatio);
            
            // Критерии для восходящего тренда
            const isUptrend = totalBid > totalAsk * 1.5 && // Покупок на 50% больше
                             imbalance > 20 && // Дисбаланс более 20%
                             bidRatio > 60; // Доля покупок более 60%
            
            // Критерии для нисходящего тренда
            const isDowntrend = totalAsk > totalBid * 1.5 &&
                               imbalance < -20 &&
                               askRatio > 60;
            
            // Критерии для предупреждения
            const isWarning = Math.abs(imbalance) > 30;
            
            if (isUptrend) {
                showAlert(trendAlert, `Сильный восходящий тренд! Соотношение: ${Math.round(bidRatio)}% покупок`);
                trendStrength.textContent = Math.round(imbalance);
                trendAdvice.textContent = "Рекомендуется рассмотреть покупку. Большие объемы на покупку указывают на возможный рост цены. Установите стоп-лосс ниже ближайшего уровня поддержки.";
                
                // Включаем индикаторы
                bidAlert.classList.add('active');
                imbalanceAlert.classList.add('active');
                ratioAlert.classList.add('active');
                
                hideAlert(warningAlert);
                hideAlert(dangerAlert);
            } else if (isDowntrend) {
                showAlert(dangerAlert, `Сильный нисходящий тренд! Соотношение: ${Math.round(askRatio)}% продаж`);
                dangerAdvice.textContent = "Рекомендуется рассмотреть продажу или ожидание. Большие объемы на продажу указывают на возможное падение цены. Будьте осторожны с покупками.";
                
                hideAlert(trendAlert);
                hideAlert(warningAlert);
            } else if (isWarning) {
                showAlert(warningAlert, `Значительный дисбаланс: ${Math.round(imbalance)}%`);
                warningAdvice.textContent = imbalance > 0 ? 
                    "Наблюдается перевес покупок. Возможен краткосрочный рост, но будьте осторожны - это может быть ловушка перед разворотом." :
                    "Наблюдается перевес продаж. Возможен краткосрочный откат, но будьте осторожны - это может быть накопление перед ростом.";
                
                hideAlert(trendAlert);
                hideAlert(dangerAlert);
            } else {
                hideAlerts();
                bidAlert.classList.remove('active');
                imbalanceAlert.classList.remove('active');
                ratioAlert.classList.remove('active');
            }
        }
        
        // Обновление кластерного анализа
        function updateClusterAnalysis(bidRatio) {
            const position = Math.min(100, Math.max(0, bidRatio));
            clusterMarker.style.left = `${position}%`;
            
            if (bidRatio > 60) {
                clusterText.textContent = "Сильная покупательская ликвидность";
                clusterText.style.color = '#4caf50';
            } else if (bidRatio < 40) {
                clusterText.textContent = "Сильная продажная ликвидность";
                clusterText.style.color = '#f44336';
            } else {
                clusterText.textContent = "Нейтральная ликвидность";
                clusterText.style.color = '#8c98a8';
            }
        }
        
        // Обновление торговых рекомендаций
        function updateTradingAdvice() {
            const bidValues = Object.values(orderbook.bids);
            const askValues = Object.values(orderbook.asks);
            
            if (bidValues.length === 0 || askValues.length === 0) return;
            
            const totalBid = bidValues.reduce((sum, vol) => sum + vol, 0);
            const totalAsk = askValues.reduce((sum, vol) => sum + vol, 0);
            const imbalance = ((totalBid - totalAsk) / (totalBid + totalAsk)) * 100;
            
            const bidPrices = Object.keys(orderbook.bids).map(Number).sort((a, b) => b - a);
            const askPrices = Object.keys(orderbook.asks).map(Number).sort((a, b) => a - b);
            
            if (bidPrices.length === 0 || askPrices.length === 0) return;
            
            const bestBid = bidPrices[0];
            const bestAsk = askPrices[0];
            const spread = bestAsk - bestBid;
            const spreadPercent = (spread / bestBid) * 100;
            
            let advice = "";
            
            // Анализ спреда
            if (spreadPercent > 0.1) {
                advice += `📊 Высокий спред (${spreadPercent.toFixed(2)}%) - будьте осторожны с рыночными ордерами.\n`;
            } else {
                advice += `📊 Низкий спред (${spreadPercent.toFixed(2)}%) - хорошие условия для торговли.\n`;
            }
            
            // Анализ объемов
            if (imbalance > 20) {
                advice += `📈 Сильные покупатели (дисбаланс: ${imbalance.toFixed(1)}%). Рассмотрите покупку.\n`;
            } else if (imbalance < -20) {
                advice += `📉 Сильные продавцы (дисбаланс: ${Math.abs(imbalance).toFixed(1)}%). Рассмотрите продажу.\n`;
            } else {
                advice += `⚖️ Баланс сил (дисбаланс: ${imbalance.toFixed(1)}%). Ожидайте сигнала.\n`;
            }
            
            // Анализ уровней поддержки/сопротивления
            if (supportLevels.length > 0) {
                advice += `🛡️ Ближайшая поддержка: ${supportLevels[0].toFixed(getPricePrecision())}\n`;
            }
            
            if (resistanceLevels.length > 0) {
                advice += `🚧 Ближайшее сопротивление: ${resistanceLevels[0].toFixed(getPricePrecision())}\n`;
            }
            
            // Общие рекомендации
            advice += `\n💡 Советы:\n`;
            advice += `- Используйте лимитные ордера вместо рыночных\n`;
            advice += `- Устанавливайте стоп-лосс на 2-3% от входа\n`;
            advice += `- Фиксируйте прибыль частями: 50% на сопротивлении, 50% можно оставить\n`;
            
            tradingAdvice.textContent = advice;
        }
        
        // Отрисовка стакана
        function renderOrderbook() {
            const bidPrices = Object.keys(orderbook.bids).map(Number).sort((a, b) => b - a);
            const askPrices = Object.keys(orderbook.asks).map(Number).sort((a, b) => a - b);
            
            if (bidPrices.length === 0 || askPrices.length === 0) {
                bidsContainer.innerHTML = '<div class="loading">Нет данных для покупок</div>';
                asksContainer.innerHTML = '<div class="loading">Нет данных для продаж</div>';
                return;
            }
            
            const bidValues = Object.values(orderbook.bids);
            const askValues = Object.values(orderbook.asks);
            const maxBid = Math.max(...bidValues);
            const maxAsk = Math.max(...askValues);
            const maxVolume = Math.max(maxBid, maxAsk);
            
            // Отрисовываем покупки
            bidsContainer.innerHTML = '';
            bidPrices.slice(0, 20).forEach(price => {
                const quantity = orderbook.bids[price];
                const width = Math.max(5, (quantity / maxVolume) * 100);
                
                const isSupport = supportLevels.some(level => Math.abs(level - price) < price * 0.001);
                
                const row = document.createElement('div');
                row.className = 'order-row bid';
                if (isSupport) {
                    row.classList.add('support-level');
                }
                
                row.innerHTML = `
                    ${isSupport ? '<div class="level-label">Поддержка</div>' : ''}
                    <span class="price">${price.toFixed(getPricePrecision(price))}</span>
                    <span class="size">${quantity.toFixed(6)}</span>
                    <div class="size-bar" style="width: ${width}%"></div>
                `;
                bidsContainer.appendChild(row);
            });
            
            // Отрисовываем продажи
            asksContainer.innerHTML = '';
            askPrices.slice(0, 20).forEach(price => {
                const quantity = orderbook.asks[price];
                const width = Math.max(5, (quantity / maxVolume) * 100);
                
                const isResistance = resistanceLevels.some(level => Math.abs(level - price) < price * 0.001);
                
                const row = document.createElement('div');
                row.className = 'order-row ask';
                if (isResistance) {
                    row.classList.add('resistance-level');
                }
                
                row.innerHTML = `
                    ${isResistance ? '<div class="level-label">Сопротивление</div>' : ''}
                    <span class="price">${price.toFixed(getPricePrecision(price))}</span>
                    <span class="size">${quantity.toFixed(6)}</span>
                    <div class="size-bar" style="width: ${width}%"></div>
                `;
                asksContainer.appendChild(row);
            });
            
            // Обновляем спред
            const bestBid = bidPrices[0];
            const bestAsk = askPrices[0];
            const spreadValue = bestAsk - bestBid;
            const spreadPercent = (spreadValue / bestBid) * 100;
            
            spreadElement.textContent = `Спред: ${spreadValue.toFixed(getPricePrecision(spreadValue))} (${spreadPercent.toFixed(2)}%) | Покупка: ${bestBid.toFixed(getPricePrecision(bestBid))} | Продажа: ${bestAsk.toFixed(getPricePrecision(bestAsk))}`;
            lastPrice.textContent = ((bestBid + bestAsk) / 2).toFixed(getPricePrecision((bestBid + bestAsk) / 2));
            
            updateDepthChart(bidPrices, askPrices, maxVolume);
        }
        
        // Вычисление статистики
        function calculateStats() {
            const bidValues = Object.values(orderbook.bids);
            const askValues = Object.values(orderbook.asks);
            
            const totalBid = bidValues.reduce((sum, vol) => sum + vol, 0);
            const totalAsk = askValues.reduce((sum, vol) => sum + vol, 0);
            const totalVolume = totalBid + totalAsk;
            
            totalBidVolume.textContent = totalBid.toFixed(2);
            totalAskVolume.textContent = totalAsk.toFixed(2);
            
            const imbalance = totalVolume > 0 ? ((totalBid - totalAsk) / totalVolume) * 100 : 0;
            orderbookImbalance.textContent = `${imbalance.toFixed(2)}%`;
            orderbookImbalance.style.color = imbalance >= 0 ? '#4caf50' : '#f44336';
            
            const maxBid = bidValues.length > 0 ? Math.max(...bidValues) : 0;
            const maxAsk = askValues.length > 0 ? Math.max(...askValues) : 0;
            
            maxBidDensity.textContent = maxBid.toFixed(6);
            maxAskDensity.textContent = maxAsk.toFixed(6);
            
            const ratio = totalAsk > 0 ? (totalBid / totalAsk).toFixed(2) : '∞';
            volumeRatio.textContent = `${ratio}:1`;
            volumeRatio.style.color = totalBid > totalAsk ? '#4caf50' : '#f44336';
        }
        
        // Вспомогательные функции
        function setStatus(status, message) {
            statusText.textContent = message;
            statusIndicator.className = 'status-indicator';
            statusIndicator.classList.add(`status-${status}`);
        }
        
        function showError(message, showRetry = false) {
            errorContainer.innerHTML = `
                <div class="error-message">
                    <strong>Ошибка:</strong> ${message}
                    ${showRetry ? '<button class="retry-button" onclick="handleConnect()">Повторить попытку</button>' : ''}
                </div>
            `;
        }
        
        function showAlert(alertElement, message) {
            alertElement.querySelector('strong').textContent = message;
            alertElement.classList.add('visible');
            
            if (alertTimeout) clearTimeout(alertTimeout);
            alertTimeout = setTimeout(() => hideAlert(alertElement), 10000);
        }
        
        function hideAlert(alertElement) {
            if (alertElement) {
                alertElement.classList.remove('visible');
            }
        }
        
        function hideAlerts() {
            hideAlert(trendAlert);
            hideAlert(warningAlert);
            hideAlert(dangerAlert);
        }
        
        function clearError() {
            errorContainer.innerHTML = '';
        }
        
        function resetOrderbook() {
            orderbook = { bids: {}, asks: {} };
            bidsContainer.innerHTML = asksContainer.innerHTML = '<div class="loading">Загрузка данных...</div>';
            spreadElement.textContent = 'Спред: Загрузка...';
            totalBidVolume.textContent = totalAskVolume.textContent = '0';
            orderbookImbalance.textContent = '0%';
            maxBidDensity.textContent = maxAskDensity.textContent = '0';
            volumeRatio.textContent = '1:1';
            priceChange.textContent = '0%';
            bidDepth.style.width = askDepth.style.width = '0%';
            lastPrice.textContent = '0';
            tradingAdvice.textContent = 'Загрузка данных...';
            clusterMarker.style.left = '50%';
            clusterText.textContent = 'Нейтральная ликвидность';
            clusterText.style.color = '#8c98a8';
        }
        
        // Функция для определения точности отображения цены
        function getPricePrecision(price = 0) {
            // Если цена меньше 0.0001, показываем 8 знаков после запятой
            if (price < 0.0001) return 8;
            // Если цена меньше 0.01, показываем 6 знаков после запятой
            if (price < 0.01) return 6;
            // Если цена меньше 1, показываем 4 знака после запятой
            if (price < 1) return 4;
            // Если цена меньше 100, показываем 3 знака после запятой
            if (price < 100) return 3;
            // Если цена меньше 1000, показываем 2 знака после запятой
            if (price < 1000) return 2;
            // Для больших цен показываем 2 знака после запятой
            return 2;
        }
        
        function updateDepthChart(bidPrices, askPrices, maxVolume) {
            bidDepth.style.width = askDepth.style.width = '0%';
            if (bidPrices.length === 0 || askPrices.length === 0) return;
            
            let cumulativeBid = 0, cumulativeAsk = 0;
            for (let i = 0; i < Math.min(bidPrices.length, 50); i++) {
                cumulativeBid += orderbook.bids[bidPrices[i]];
            }
            for (let i = 0; i < Math.min(askPrices.length, 50); i++) {
                cumulativeAsk += orderbook.asks[askPrices[i]];
            }
            
            const maxCumulative = Math.max(cumulativeBid, cumulativeAsk);
            if (maxCumulative > 0) {
                bidDepth.style.width = `${(cumulativeBid / maxCumulative) * 50}%`;
                askDepth.style.width = `${(cumulativeAsk / maxCumulative) * 50}%`;
            }
        }
    </script>
</body>
</html>
